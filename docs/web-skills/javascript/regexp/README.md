# 正则表达式

## 在线解析工具

* [正则表达式解析工具](https://jex.im/regulex/)

## 语法

1. 修饰符
   * i 大小写不敏感
   * g 全局匹配
   * m 多行匹配

2. 零宽先行断言，只匹配（正向）或不匹配（反向）表达式前面的内容
   正向：(?=x) x 表示匹配的内容，例如：/x(?=y)/ x只有在y前面才匹配
   负向：(?!x) x 表示不匹配的内容，例如：/x(?!y)/ x只有不在y前面才匹配
3. 零宽后行断言（ES2018 引入），只匹配（正向）或不匹配（反向）表达式后面的内容
   [https://es6.ruanyifeng.com/#docs/regex#后行断言](https://es6.ruanyifeng.com/#docs/regex)
   正向：(?<=y) x 表示匹配的内容，例如：/(?<y)x/  x只有在y后面才匹配
   负向：(?<!x) x 表示不匹配的内容，例如：/(?<!y)x/  x只有不在y后面才匹配
4. 关于 stringObject.replace(regexp/substr,replacement) 中 replacement 几个特殊字符说明
   | 字符 | 替换文本 |
   | $1、$2、...、$99 | 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本 |
   | $& | 与 regexp 相匹配的内容 |
  | $` | 位于匹配内容左侧的文本 |
  | $' | 位于匹配子串右侧的文本 |
  | $$ | 直接量符号 |

## 常用正则表达式

1. 匹配中文

   ```javascript
     const reg = /[\u4e00-\u9fa5]/;
   ```

2. 匹配车牌号

   ```javascript
     /*
       1.常规车牌号：仅允许以汉字开头，后面可录入六个字符，由大写英文字母和阿拉伯数字组成。如：粤B12345；
       2.武警车牌：允许前两位为大写英文字母，后面可录入五个或六个字符，由大写英文字母和阿拉伯数字组成，其中第三位可录汉字也可录大写英文字母及阿拉伯数字，第三位也可空，如：WJ警00081、WJ京1234J、WJ1234X。
       3.最后一个为汉字的车牌：允许以汉字开头，后面可录入六个字符，前五位字符，由大写英文字母和阿拉伯数字组成，而最后一个字符为汉字，汉字包括“挂”、“学”、“警”、“军”、“港”、“澳”。如：粤Z1234港。
       4.新军车牌：以两位为大写英文字母开头，后面以5位阿拉伯数字组成。如：BA12345。
      */
      const carnumRegex = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[警京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼]{0,1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
   ```

   对于普通车牌号可以稍作修改
3. 日期匹配

   ```javascript
     // 包含闰年、以及包括平年在内的所有年份1、3、5、7、8、10、12月都包含31日
     // 匹配从0001年到9999年的各年月日
     // 注意前后的括号不能去掉，去掉的话可以匹配比如 10000等的年份
     const reg=  /^((?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)$/;
   ```

    变体，只匹配2000到2099年的正则

    ```javascript
      const reg = /^(20[0-9]{2}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|(20(0[048]|[2468][048]|[13579][26]))-02-29)$/;
    ```

    变体2，匹配1900到2099年的正则

    ```javascript
      const reg = /^((19|20)[0-9]{2}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|((19|20)(0[48]|[2468][048]|[13579][26])|2000)-02-29)$/;
    ```

4. 身份证匹配

    ```javascript
      const reg = /^[1-9][0-9]{5}((19|20)[0-9]{2}((0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])(29|30)|(0[13578]|1[02])31)|((19|20)(0[48]|[2468][048]|[13579][26])|2000)0229)[0-9]{3}[0-9xX]$/;
    ```

   前六位为地区名，中间8位为年月日，只匹配了1900~2099年的，包括大小月，闰月，其中前六位没有判断是否存在
5. 匹配 URL 路径最后一级

   ```typescript
     /**
      * 匹配最后一个 path
      * [^/]+ 表示匹配任意长度的字符串，字符串中不包含有字符 /，可以把以 / 分割开的字符串全匹配到
      .*\/ 表示任意以 / 结尾的字符串，可以把字符串后带有 / 的字符串匹配到，前面再加上 ?!，再用圆括号括起来表示排除掉 (?!.*\/)
      */
     const pathMatch = /[^/]+(?!.*\/)/;
   ```

   以上写法会匹配到带参数或路由的 url，如果 url 中没有带参数的情况，可以使用，另外更严格的写法如下

   ```typescript
     const pathMatch = /[^/?#]+(?!.*\/)/;
   ```

6. 域名匹配

   ```javascript
     const reg = /^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$/;
   ```

7. url 匹配
   参考地址：<https://blog.csdn.net/wangchaoqi1985/article/details/82810471>

   ```javascript
      const reg = /(https?|ftp|file):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/;
    ```

   变体，去掉前面的 http:// 或 https://或其他

   ```javascript
     const reg = /(?!.+:\/\/)[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/;
   ```

8. 邮箱正则表达式

   ```javascript
   // https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
   const reg = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
   ```
